package com.ucpb.tfs2.infrastructure.rest
import com.google.gson.Gson
import com.ucpb.tfs.application.service.AccountingService
import com.ucpb.tfs.application.service.AllocationUnitCodeService
import com.ucpb.tfs.application.service.AmlaExpiredLcService
import com.ucpb.tfs.application.service.CifNormalizationLogService
import com.ucpb.tfs.batch.job.*
import com.ucpb.tfs.core.batch.process.CifNormalization
import com.ucpb.tfs.core.batch.process.FacilityReferenceNormalization
import com.ucpb.tfs.domain.cdt.services.PAS5FilesLoaderService
import com.ucpb.tfs.domain.product.TradeProductRepository
import com.ucpb.tfs.domain.service.TradeServiceRepository
import com.ucpb.tfs.parsers.handlers.RmaBankHandler
import com.ucpb.tfs.util.FileUtil
import com.ucpb.tfs.utils.DateUtil
import com.ucpb.tfs2.application.service.RefBankService
import com.ucpb.tfs2.application.service.casa.exception.CasaServiceException
import groovy.io.FileType
import org.apache.commons.io.IOUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.beans.factory.config.PropertiesFactoryBean
import org.springframework.stereotype.Component
import org.springframework.util.Assert
import org.xml.sax.SAXException
import org.xml.sax.helpers.DefaultHandler

import javax.annotation.Resource
import javax.ws.rs.GET
import javax.ws.rs.Path
import javax.ws.rs.Produces
import javax.ws.rs.core.*
import javax.xml.parsers.SAXParser
import javax.xml.parsers.SAXParserFactory
import java.text.SimpleDateFormat
import java.util.List;

/**
 */

/*	PROLOGUE:
 * 	(revision)
	SCR/ER Number: IBD-15-0828-01
	SCR/ER Description: Comparison of Balances in DW and SIBS-GL
	[Revised by:] Jesse James Joson
	[Date revised:] 09/17/2015
	Program [Revision] Details: add new methods that will execute SIBS extraction
	INPUT: extractSibs
	OUTPUT: Daily_Master_GL_Summary.xls & Daily_Master_GL_DailyBalance_Summary.xls
	PROCESS: execute SIBS extraction
 */

/*	PROLOGUE:
 * 	(revision)
	SCR/ER Number: 20150820-072
	SCR/ER Description: To catch duplication in CIF.
	[Revised by:] Jesse James Joson
	[Date revised:] 10/13/2015
	Program [Revision] Details: add a response whether to failed in UI or Success.
	PROJECT: CORE
	MEMBER TYPE  : Groovy
 */

@Component
@Path("/batch")
class BatchRestServices {

    private static final String REPORT_DATE = "date"

    private static final String GL_QUERY =
            "SELECT " +
                "GL.RESPONDINGUNITCODE, " +
                "GL.BOOKCODE, " +
                "GL.ACCOUNTINGCODE, " +
                "GL.ORIGINALCURRENCY, " +
                "GL.EFFECTIVEDATE, " +
                "GL.ENTRYTYPE, " +
                "GL.PESOAMOUNT, " +
                "GL.ORIGINALAMOUNT," +
                "GL.UNITCODE, " +
                "GL.PARTICULARS, " +
                "(CASE WHEN (TS.DOCUMENTCLASS='INDEMNITY') THEN TS.DOCUMENTNUMBER ELSE TS.TRADEPRODUCTNUMBER END) AS DOCUMENTNUMBER, " +
                "GL.ID, " +
                "TS.SERVICEINSTRUCTIONID, " +
                "GL.TRANSACTIONSHORTNAME, " +
                "GL.SERVICETYPE, " +
                "TS.DOCUMENTCLASS, " +
                "TS.DOCUMENTTYPE, " +
                "GL.UCPBPRODUCTID, " +
                "TS.CIFNAME, " +
                "TS.TRADESERVICEREFERENCENUMBER " +
            "FROM INT_ACCENTRYACTUAL GL " +
                "INNER JOIN TRADESERVICE TS ON TS.TRADESERVICEID = GL.TRADESERVICEID " +
            "WHERE " +
                "DAYS(GL.EFFECTIVEDATE) = DAYS(CAST(? AS TIMESTAMP)) AND GL.STATUS IN ('APPROVED','PRE_APPROVED','POST_APPROVED','POSTED', 'EXPIRED','REINSTATED') AND " +
                "GL.TRADESERVICEID NOT IN (SELECT GLSUB.TRADESERVICEID FROM INT_ACCENTRYACTUAL GLSUB WHERE (GLSUB.WITHERROR IS NOT NULL AND (LENGTH(TRIM(GLSUB.WITHERROR)) > 0))) "+
				
			//added for Auto Expired Cancellation
			"UNION " + 	
			"SELECT  " +
				"GLE.RESPONDINGUNITCODE, " +
				"GLE.BOOKCODE, " +
				"GLE.ACCOUNTINGCODE, " +
				"GLE.ORIGINALCURRENCY, " +
				"GLE.EFFECTIVEDATE, " +
				"GLE.ENTRYTYPE, " +
				"GLE.PESOAMOUNT, " +
				"GLE.ORIGINALAMOUNT,  " +
				"GLE.UNITCODE,  " +
				"GLE.PARTICULARS,  " +
				"TPE.DOCUMENTNUMBER as DOCUMENTNUMBER,  " +
				"GLE.ID,  " +
				//no tradeServiceId since it is not a transaction
				"\'\',  " +
				"GLE.TRANSACTIONSHORTNAME,  " +
				"GLE.SERVICETYPE, " +
				"\'\', " +
				"\'\',  " +
				"GLE.UCPBPRODUCTID, " +
				"TPE.CIFNAME, " +
				"TPE.DOCUMENTNUMBER " +
			"FROM INT_ACCENTRYACTUAL GLE " +
			//change from tradeservice to tradeproduct for the multiple upload of expired lc bug
				"INNER JOIN TRADEPRODUCT TPE ON TPE.DOCUMENTNUMBER = GLE.DOCUMENTNUMBER " +
			"where " +
				"DATE(GLE.EFFECTIVEDATE) = ? AND GLE.ACCEVTRANID = 'CANCELLATION-EXPIRED-LC' AND "+
			 	//"GLE.ISPOSTED IS NULL AND GLE.status='EXPIRED' AND " +  //@carlo uncomment changging cancellation to effective date
				"TPE.PRODUCTTYPE='LC' " +
			//for untag gl
			"UNION " +
			"SELECT "+
				" GLP.RESPONDINGUNITCODE, " +
					"GLP.BOOKCODE, " +
					"GLP.ACCOUNTINGCODE, " +
					"GLP.ORIGINALCURRENCY, " +
					"GLP.EFFECTIVEDATE, " +
					"GLP.ENTRYTYPE, " +
					"GLP.PESOAMOUNT, " +
					"GLP.ORIGINALAMOUNT, " +
					"GLP.UNITCODE, " +
					"GLP.PARTICULARS, " +
					"(CASE WHEN (TSP.DOCUMENTCLASS='INDEMNITY') THEN TSP.DOCUMENTNUMBER ELSE TSP.TRADEPRODUCTNUMBER END) AS DOCUMENTNUMBER, " +
					"GLP.ID, " +
					"TSP.SERVICEINSTRUCTIONID, " +
					"GLP.TRANSACTIONSHORTNAME, " +
					"GLP.SERVICETYPE, " +
					"TSP.DOCUMENTCLASS, " +
					"TSP.DOCUMENTTYPE, " +
					"GLP.UCPBPRODUCTID, " +
					"TSP.CIFNAME, " +
					"TSP.TRADESERVICEREFERENCENUMBER " +
				"FROM INT_ACCENTRYACTUAL GLP " +
					"INNER JOIN TRADESERVICE TSP ON TSP.TRADESERVICEID = GLP.TRADESERVICEID " +
				"WHERE " +
					"GLP.ISPOSTED <> 1 AND GLP.STATUS IN ('APPROVED','PRE_APPROVED','POST_APPROVED','POSTED', 'EXPIRED','REINSTATED') AND " +
					"GLP.TRADESERVICEID NOT IN (SELECT GLSUBP.TRADESERVICEID FROM INT_ACCENTRYACTUAL GLSUBP WHERE (GLSUBP.WITHERROR IS NOT NULL AND (LENGTH(TRIM(GLSUBP.WITHERROR)) > 0))) ";
					
					
    private static final String TRANSACTION_LOG_QUERY = "SELECT * from TRANSACTIONLOG WHERE DAYS(TXNDATE) = DAYS(cast(? as timestamp)) " + 
											"AND TRANSACTIONTYPECODE IN ('ICOBD','ICDCC','IDLDC','IDLDD','IDLDM','IDLIC','IDLID','IDLIM','IDLSD','IDNIC','IDNID','IDNIM','IOBLC','IOBLK','IOBLM','IOBNC','IOBNK','IOBNM','ILCC') or BATCHFLAG = 1 " +
											"ORDER BY TXNDATE ASC";

    private static final String ACCOUNT_LOG_QUERY = "select * from ACCOUNTLOG WHERE DAYS(DATE_CREATED) = DAYS(cast(? as timestamp)) or BATCHFLAG = 1 ORDER BY DATE_CREATED ASC";

    private static final String CUSTOMER_ACCOUNT_LOG_QUERY = "SELECT * from CUSTOMERACCOUNT WHERE DAYS(DATE_CREATED) = DAYS(cast(? as timestamp)) or BATCHFLAG = 1 ORDER BY DATE_CREATED ASC";

    private static final String CUSTOMER_LOG_QUERY = "SELECT ID, customerType, firstName, middleName, lastName,gender,dateOfBirth," +
            "placeOfBirth,maritalStatus,'' AS DUMMY,nationality,cntry_iso,businessAddress1,businessAddress2,businessAddress3,businessAddress4," +
            "businessAddressZipCode,lengthOfStayInPresentAddress,permanentAddress1,permanentAddress2,permanentAddress3,permanentAddress4,permanentAddressZipCode," +
            "lengthOfStayInPermanentAddress,occupation,natureOfBusiness,monthlyIncome,annualIncome,financialStatus,individualOrCorporate,financialStatus,residencePhoneNumber," +
            "officePhoneNumber,mobileNumber,natureofselfemployment,sourceoffunds " +
            "from CUSTOMERLOG cust " +
            "left join REF_TFCNTRY cntry on cust.nationOfBirth = cntry.cntry_cd " +
            "WHERE DAYS(LAST_UPDATED) = DAYS(cast(? as timestamp)) ORDER BY LAST_UPDATED ASC";

    private static final String AMLA_TOTALS_QUERY = "select 'TRN71.txt' as FILENAME, count(TXNREFERENCENUMBER) as TOTALRECORDS, sum(transactionAmount) as TOTALAMOUNT from transactionLog where DAYS(TXNDATE) = DAYS(cast(? as timestamp))" +
			"AND TRANSACTIONTYPECODE IN ('ICOBD','ICDCC','IDLDC','IDLDD','IDLDM','IDLIC','IDLID','IDLIM','IDLSD','IDNIC','IDNID','IDNIM','IOBLC','IOBLK','IOBLM','IOBNC','IOBNK','IOBNM','ILCC') " +
			" union " +
            "select 'ACC71.txt' as FILENAME, count(ID) as TOTALRECORDS, null as TOTALAMOUNT from accountLog where DAYS(DATE_CREATED) = DAYS(cast(? as timestamp))" +
            " union " +
            "select 'CAC71.txt' as FILENAME, count(ID) as TOTALRECORDS, null as TOTALAMOUNT from customerAccount where DAYS(DATE_CREATED) = DAYS(cast(? as timestamp))";

    private static final String DATE_FORMAT = "MM-dd-yyyy";
    private static final String DATE_FORMAT_DESC = "yyyy-MM-dd";
	private static final String DATE_FORMAT_BATCH_CONTROLLER = "MM-dd-yyyy";

    private static final SimpleDateFormat DATE_FORMATTER = new SimpleDateFormat(DATE_FORMAT);
    private static final SimpleDateFormat DATE_FORMATTER_DESC = new SimpleDateFormat(DATE_FORMAT_DESC);
	private static final SimpleDateFormat DATE_FORMATTER_BATCH_CONTROLLER = new SimpleDateFormat(DATE_FORMAT_BATCH_CONTROLLER);

    private static final String DW_PARAMETER_FILE_SQL = "SELECT * FROM DW_REFERENCE WHERE REF_TYPE = 'CBR'";
    private static final String CBR_PARAMETER_FILE_SQL = "SELECT * FROM DW_REFERENCE WHERE REF_TYPE = 'CBR1' ORDER BY FIELD, PRODUCTID";


	private static final String GL_PARAMETER_FILE_SQL = "SELECT DISTINCT GLCODE, RECORDTYPE FROM GL_ENTRY_TYPES";

	private static final String PUSO_CFMAST_SQL = "SELECT CFSNME, CFOFFR, CFNA1, CFNA1A, CFRESD, CFBIRD, CFBIR6 FROM CFMAST";

    //TODO MOVE THIS QUERIES PROPERTIES INTO PROPERTIES FILE


    @Autowired
    @Qualifier("transactionLogGeneratorJob")
    private CsvReportGeneratorJob transactionLogJob;

    @Autowired
    @Qualifier("accountLogGeneratorJob")
    private CsvReportGeneratorJob accountLogJob;

    @Autowired
    @Qualifier("customerAccountLogGeneratorJob")
    private CsvReportGeneratorJob customerAccountLogGeneratorJob;

    @Autowired
    @Qualifier("customerLogGeneratorJob")
    private CsvReportGeneratorJob customerLogGeneratorJob;

    @Autowired
    @Qualifier("amlaTotalsGeneratorJob")
    private CsvReportGeneratorJob amlaTotalsLogJob;

    @Autowired
    @Qualifier("glReportGeneratorJob")
    private GlReportGeneratorJob glReportGenerator;

	@Autowired
	@Qualifier("cifPurgingGeneratorJob")
	private CifPurgingGeneratorJob cifPurgingGeneratorJob;
	
	@Autowired
	private AmlaExpiredLcService amlaExpiredLcService;
	
    @Autowired
    @Qualifier("abortPendingEtsReversalJob")
    private AbortPendingEtsReversalJob abortPendingEtsReversalJob;

	@Autowired
    @Qualifier("cifNormalization")
    private CifNormalization cifNormalization;

    @Autowired
    @Qualifier("facilityReferenceNormalization")
    private FacilityReferenceNormalization facilityReferenceNormalization;

    @Autowired
    private MasterFileReportGeneratorJob masterFileReportGeneratorJob;
	
	@Autowired
	private MasterExcelFileGeneratorJob masterExcelFileGeneratorJob;

    @Autowired
    private AllocationFileReportGeneratorJob glAllocationsReportJob;

	@Autowired
	private AllocationExcelFileGeneratorJob glAllocationsExcelJob;

	@Autowired
	private SibsExtractionJob sibsExtractionJob;
	
    @Autowired
    @Resource(name = "dailyBalanceRecorderJob")
    private SpringJob dailyBalanceRecorderJob;
//    private SqlRunnerJob dailyBalanceRecorderJob;

    @Autowired
    @Resource(name = "tradeServiceRevertJob")
    private SpringJob tradeServiceRevertJob;
    
    @Autowired
    @Resource(name = "serviceInstructionRevertJob")
    private SpringJob serviceInstructionRevertJob;

    @Autowired
    @Resource(name = "tradeProductExpireJob")
    private SpringJob tradeProductExpireJob;

    @Autowired
    @Qualifier("setExpiredLcsStatusToExpired")
    private SpringJob setExpiredLcsStatusToExpired;

    @Autowired
    @Resource(name = "cancelDormantEtsJob")
    private SpringJob cancelDormantEtsJob;
    
    @Autowired
    @Resource(name = "uploadRoutingJob")
    private SpringJob uploadRoutingJob;

    @Autowired
    @Qualifier("glParameterFileJob")
    private FixedFileReportGeneratorJob glParameterFileJob;

    @Autowired
    @Qualifier("dwParameterRecord")
    private FixedFileReportGeneratorJob dwParameterRecord;

    @Autowired
    @Qualifier("cbrParameterFileGenerator")
    private FixedFileReportGeneratorJob cbrParameterFileGenerator;

	@Autowired
	private PAS5FilesLoaderService pas5FilesLoaderService;

    @Autowired
    private TradeProductRepository tradeProductRepository;
	
    @Autowired
    private TradeServiceRepository tradeServiceRepository;

    @Autowired
    private CifNormalizationLogService cifNormalizationLogService;

    @Autowired
    @Resource(name = "batchFacilityRevaluationJob")
    private SpringJob batchFacilityRevaluationJob;

    @Autowired
    private PurgeSecEmloyeeAuditJob purgeSecEmloyeeAuditJob;

	@Autowired
	RefBankService refBankService
	
	@Autowired
	PropertiesFactoryBean appProperties

    @Autowired
    AllocationUnitCodeService allocationUnitCodeService
	
	@Autowired
	AccountingService accountingService

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/master")
    public Response generateMasterFile(@Context UriInfo allUri){
		println "\n--- START: Master File, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
        Assert.notNull(reportDate,"Report date must not be null!")
        println "reportDate:"+reportDate
		try{
			String masterDate = DATE_FORMATTER_DESC.format(DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate)) + "-00.00.00"
            println "masterDate:"+masterDate
            masterFileReportGeneratorJob.execute(masterDate);
			masterExcelFileGeneratorJob.execute(masterDate);
			println "\n--- END (SUCCESS): Master File, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Master File'])).build();
		}catch(Exception e){
			e.printStackTrace();
			System.err.println("Master: "+e.getCause()?.getMessage())
			println "\n--- END (FAILED): Master File, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/extractSibs")
	public Response extractSibs(@Context UriInfo allUri){
		println "\n--- START: Extract Sibs, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();
		MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
		String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
		Assert.notNull(reportDate,"Report date must not be null!")
		println "reportDate:"+reportDate
		try{
			String masterDate = DATE_FORMATTER_DESC.format(DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate)) + "-00.00.00"
			println "masterDate:"+masterDate
			sibsExtractionJob.execute(masterDate);
			println "\n--- END (SUCCESS): Extract SIBS GL Accounts, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Extract SIBS GL Accounts'])).build();
		}catch(Exception e){
			e.printStackTrace();
			System.err.println("Master: "+e.getCause()?.getMessage())
			println "\n--- END (FAILED): Extract SIBS GL Accounts, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
	}
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/masterException")
	public Response generateMasterExceptionReport(@Context UriInfo allUri){
		println "\n--- START: Master Exception Report, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();
		MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
		String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
		Assert.notNull(reportDate,"Report date must not be null!")
		println "reportDate:"+reportDate
		try{
			String masterExceptionDate = DATE_FORMATTER_DESC.format(DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate)) + "-00.00.00"
			println "masterExceptionDate:"+masterExceptionDate
			masterExcelFileGeneratorJob.executeMasterExceptionReport(masterExceptionDate);
			println "\n--- END (SUCCESS): Master Exception Report, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Master Exception Report'])).build();
		}catch(Exception e){
			e.printStackTrace();
			System.err.println("Master: "+e.getCause()?.getMessage())
			println "\n--- END (FAILED): Master Exception Report, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
	}
	
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/revertToPending")
    public Response revertUnapprovedTradeServices(@Context UriInfo allUri){
        println "\n--- START: Revert Data Entry to Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
		try{
			tradeServiceRevertJob.execute();
            println "\n--- END (SUCCESS): Revert Data Entry to Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Revert Data Entry to Pending'])).build();
		}catch(Exception e){
            e.printStackTrace();
			System.err.println("revertToPending: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): Revert Data Entry to Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }
    
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/etsToPending")
    public Response revertUnapprovedServiceInstructions(@Context UriInfo allUri){
    	println "\n--- START: Revert e-TS to Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
    	Gson gson = new Gson();
    	try{
    		serviceInstructionRevertJob.execute();
    		println "\n--- END (SUCCESS): Revert e-TS to Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
    		return Response.status(200).entity(gson.toJson([success : true,name:'Revert e-TS to Pending'])).build();
    	}catch(Exception e){
    		e.printStackTrace();
    		System.err.println("etsToPending: "+e.getCause()?.getMessage())
    		println "\n--- END (FAILED): Revert e-TS to Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
    		return Response.status(200).entity(gson.toJson([success : false])).build();
    	}
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/expireLcs")
    public Response changeExpiredLcStatuses(@Context UriInfo allUri){
        Gson gson = new Gson();
		try{
            MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
            String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
            Assert.notNull(reportDate,"Report date must not be null!")

			 setExpiredLcsStatusToExpired.execute(reportDate);
			 return Response.status(200).entity(gson.toJson([success : true,name:'Process Expired LCs'])).build();
		}catch(Exception e){
            e.printStackTrace();
			System.err.println("expireLcs: "+e.getCause()?.getMessage())
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/tagLcAsExpired")
    public Response changeExpiredLcStatusesWithAccounting(@Context UriInfo allUri){
        println "\n--- START: Tag LC as Expired, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        try {
            MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
            String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
//            Assert.notNull(reportDate,"Report date must not be null!")
            if(reportDate == null){
				tradeProductExpireJob.execute(); // for expired LC
                tradeProductRepository.updateTrade("UPDATE TRADEPRODUCT SET STATUS = 'EXPIRED' WHERE DOCUMENTNUMBER IN (SELECT LC.DOCUMENTNUMBER FROM LETTEROFCREDIT LC JOIN TRADEPRODUCT TP ON LC.DOCUMENTNUMBER = TP.DOCUMENTNUMBER WHERE LC.TYPE <> 'CASH' AND TP.STATUS IN ('OPEN','REINSTATED') AND LC.EXPIRYDATE <= CAST(CURRENT_TIMESTAMP AS TIMESTAMP))");
				
				
            } else {
                // MM-dd-yyyy
				String[] split = reportDate.split("-")
				String MM = split[0]
				String dd = split[1]
				String yyyy = split[2]
				SimpleDateFormat df1 = new SimpleDateFormat("MM/dd/yyyy");
				SimpleDateFormat df2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				Date date = df1.parse(MM+"/"+dd+"/"+yyyy);  // Does not have time component, meaning this is midnight...
														// ...so we need to add one day as the "limit"
				
				//Expired LC Batch Run early morning including holidays and weekends
				//tag as 'EXPIRED' for those LCs which was matured a day before
				Calendar dateToday = GregorianCalendar.getInstance();
				dateToday.setTime(date);
				dateToday.add(GregorianCalendar.DATE, -1);
				Date dateToExpire = dateToday.getTime();
				
                String timestampFormattedDate = reportDate+"-00.00.00"
                println "timestampFormattedDate:"+timestampFormattedDate
				println "Date to Expire: "+dateToExpire+"-00.00.0"
               
                
                GregorianCalendar cal = GregorianCalendar.getInstance();
                cal.setTime(date);
				//cal.add(GregorianCalendar.DATE, 1);
				
                println ">>>>>>>>>>>>>>>>>> date = ${date}"
                //println ">>>>>>>>>>>>>>>>>> limit = ${cal.getTime()}"

                String update = "UPDATE TRADEPRODUCT SET STATUS = 'EXPIRED' WHERE DOCUMENTNUMBER IN (SELECT LC.DOCUMENTNUMBER FROM LETTEROFCREDIT LC JOIN TRADEPRODUCT TP ON LC.DOCUMENTNUMBER = TP.DOCUMENTNUMBER WHERE LC.TYPE <> 'CASH' AND TP.STATUS IN ('OPEN','REINSTATED') AND LC.EXPIRYDATE <= CAST('${df2.format(cal.getTime())}' AS TIMESTAMP))"
				tradeProductExpireJob.execute(reportDate);
				//update TradeProduct table and create a reversal entry for those recently expired LC
				println "setExpiredLcsStatusToExpired.execute();"
                tradeProductRepository.updateTrade(update);
				println "tradeProductExpireJob.execute();"
				 // for expired LC

            }
            println "\n--- END (SUCCESS): Tag LC as Expired, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : true,name:'Expire LCs'])).build();
        }catch(Exception e){
            e.printStackTrace();
            System.err.println("expireLcs: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): Tag LC as Expired, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : false])).build();
        }
    }
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/reverseOrCancelLc")
	public Response reverseOrCancelLc(@Context UriInfo allUri){
		println "\n--- START: Reverse or Cancel LCs, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();
		try {
			MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
			String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
//            Assert.notNull(reportDate,"Report date must not be null!")
			if(reportDate == null){
				println "report date is null"
				// tradeProductExpireJob.execute();=> earmarking is done during process revalue batch
			} else {
				// MM-dd-yyyy
				String timestampFormattedDate = reportDate+"-00.00.00"
				println "timestampFormattedDate:"+timestampFormattedDate
				println "tradeProductExpireJob.execute();"
				//tradeProductExpireJob.execute(reportDate); => earmarking is done during process revalue batch
			}
			println "\n--- END (SUCCESS): Reverse or Cancel LCs, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Reverse Expired LC'])).build();
		}catch(Exception e){
			e.printStackTrace();
			System.err.println("expireLcs: "+e.getCause()?.getMessage())
			println "\n--- END (FAILED): Reverse or Cancel LCs, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
	}

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/purgeEts")
    public Response purgeEts(@Context UriInfo allUri){
        println "\n--- START: Purge Unapproved ETS, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        String reportDate = allUri.getQueryParameters()?.getFirst(REPORT_DATE)?.toString();
        Assert.notNull(reportDate,"Report date must not be null!")
        println "reportDate: " + reportDate
        try{
			String[] documentNumbers = tradeServiceRepository.getDocumentNumbersOfUnapprovedEts(DATE_FORMATTER.parse(reportDate))
			println "documentNumbers: " + documentNumbers
			cancelDormantEtsJob.execute(reportDate);
			if (documentNumbers.length > 0){
				facilityReferenceNormalization.deleteOutstandingUnapprovedFacilityAvailment(documentNumbers)
				println facilityReferenceNormalization.test(documentNumbers)
			}
            println "\n--- END (SUCCESS): Purge Unapproved ETS, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Purge Unapproved ETS'])).build();
	   }catch(Exception e){
	   		System.err.println("purgeEts: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): Purge Unapproved ETS, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		    return Response.status(200).entity(gson.toJson([success : false])).build();
	   }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/gl")
    public Response generateGl(@Context UriInfo allUri){
		println "\n--- START: GL Movement, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
		try{
			MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
			String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
			Assert.notNull(reportDate,"Report date must not be null!")
            println "reportDate = ${reportDate}"
            glReportGenerator.execute(GL_QUERY, DATE_FORMATTER.parse(reportDate), getDate(reportDate));
			println "tag all gl as posted"
			accountingService.updateIsPosted();
			
			Boolean balanceChecking = accountingService.balanceChecking();
			println "\n.. Checking Accounting Entries Debit vs Credit..."
			if(balanceChecking) {
				println "All are balance"
			}else {
				throw new Exception("GL Entires are Not Balance");
			}
			
            println "\n--- END (SUCCESS): GL Movement, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success:true,name:'GL Movement'])).build();
	   }catch(Exception e){
            e.printStackTrace();
	   		System.err.println("gl: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): GL Movement, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
	   }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/abortPendingEtsReversal")
    public Response abortPendingEtsReversal(@Context UriInfo allUri){
		println "\n--- START: Abort Pending ETS Reversal, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
		try{
			abortPendingEtsReversalJob.execute();
            println "\n--- END (SUCCESS): Abort Pending ETS Reversal, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Abort Pending ETS Reversal'])).build();
	   }catch(Exception e){
	   		System.err.println("abortPendingEtsReversal: "+ e.getCause()?.getMessage())
            println "\n--- END (FAILED): Abort Pending ETS Reversal, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		    return Response.status(200).entity(gson.toJson([success : false])).build();
	   }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/params")
    public Response generateParameterFiles(@Context UriInfo allUri){
		println "\n--- START Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        Map returnMap = new HashMap();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
        Assert.notNull(reportDate,"Report date must not be null!")
        println "reportDate:"+reportDate
		try{
	        glParameterFileJob.execute(GL_PARAMETER_FILE_SQL,DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate));
			println "\n--- END (SUCCESS): GL Parameter:" + DateUtil.convertToTimeString(new Date()) + "---"
	        return Response.status(200).entity(gson.toJson([success : true,name:'GL Parameter'])).build();
		}catch(Exception e){
			System.err.println("Parameter: "+ e.getCause()?.getMessage())
			println "\n--- END (FAILED): GL Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/allocation")
    public Response generateAllocation(@Context UriInfo allUri){
        println "\n--- START Allocation, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        Map returnMap = new HashMap();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
        println "reportDate:"+reportDate
        Assert.notNull(reportDate,"Report date must not be null!")
        try{
            glAllocationsReportJob.execute(DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate),"561501030000","10903");
			glAllocationsExcelJob.executeToExcel(DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate),"561501030000","10903");
            println "\n--- END (SUCCESS): Allocation:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : true,name:'Allocation File'])).build();
        }catch(Exception e){
            e.printStackTrace()
            System.err.println("Allocation: "+ e.getCause()?.getMessage())
            println "\n--- END (FAILED): Allocation, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : false])).build();
        }
    }
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/allocationException")
	public Response generateAllocationExceptionReport(@Context UriInfo allUri){
		println "\n--- START Allocation Exception Report, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();
		Map returnMap = new HashMap();
		MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
		String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
		println "reportDate:"+reportDate
		Assert.notNull(reportDate,"Report date must not be null!")
		try{
			glAllocationsExcelJob.executeAllocationExceptionReport(DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate),"561501030000","10903");
			println "\n--- END (SUCCESS): Allocation Exception Report:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : true,name:'Allocation Exception Report'])).build();
		}catch(Exception e){
			e.printStackTrace()
			System.err.println("Allocation: "+ e.getCause()?.getMessage())
			println "\n--- END (FAILED): Allocation Exception Report, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
	}

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/transaction")
    public Response generateTransactionFile(@Context UriInfo allUri){
		println "\n--- START: AMLA Transaction / Totals, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        Assert.notNull(parameters?.getFirst(REPORT_DATE)?.toString(),"Report date must not be null!")
        try{
            String dateStr = parameters?.getFirst(REPORT_DATE)?.toString();
            java.sql.Date date = getDate2(dateStr);
            println "reportDate = ${dateStr}"
            transactionLogJob.execute(TRANSACTION_LOG_QUERY, date);
            amlaTotalsLogJob.execute(AMLA_TOTALS_QUERY, date, date, date);
			amlaExpiredLcService.deleteTransLogBatchFlag();
            println "\n--- END (SUCCESS): AMLA Transaction / Totals, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success:true,name:'AMLA Transaction'])).build();
        }catch(Exception e){
            e.printStackTrace();
            System.err.println("Transaction: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): AMLA Transaction / Totals, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
        }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/customerAccount")
    public Response generateCustomerAccountFile(@Context UriInfo allUri){
		println "\n--- START: AMLA Customer Account, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        Assert.notNull(parameters?.getFirst(REPORT_DATE)?.toString(),"Report date must not be null!")
		try{
            String dateStr = parameters?.getFirst(REPORT_DATE)?.toString();
            java.sql.Date date = getDate2(dateStr);
            println "reportDate = ${dateStr}"
			customerAccountLogGeneratorJob.execute(CUSTOMER_ACCOUNT_LOG_QUERY, date);
			amlaExpiredLcService.deleteCustomerAccBatchFlag();
            println "\n--- END (SUCCESS): AMLA Customer Account, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		return Response.status(200).entity(gson.toJson([success:true,name:'AMLA Customer Account'])).build();
		}catch(Exception e){
            e.printStackTrace();
			System.err.println("customer account: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): AMLA Customer Account, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/account")
    public Response generateAccountFile(@Context UriInfo allUri){
		println "\n--- START: AMLA Account, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        Assert.notNull(parameters?.getFirst(REPORT_DATE)?.toString(),"Report date must not be null!")
		try{
            String dateStr = parameters?.getFirst(REPORT_DATE)?.toString();
            
            java.sql.Date date = getDate2(dateStr);
            println "reportDate = ${dateStr}"
			accountLogJob.execute(ACCOUNT_LOG_QUERY, date);
			amlaExpiredLcService.deleteAccountLogBatchFlag();
            println "\n--- END (SUCCESS): AMLA Account, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success:true,name:'AMLA Account'])).build();
		}catch(Exception e){
            e.printStackTrace();
			System.err.println("account: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): AMLA Account, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/customer")
    public Response generateCustomerFile(@Context UriInfo allUri){
		println "\n--- START: AMLA Customer, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        Assert.notNull(parameters?.getFirst(REPORT_DATE)?.toString(),"Report date must not be null!")
        try{
            String dateStr = parameters?.getFirst(REPORT_DATE)?.toString();
            
            java.sql.Date date = getDate2(dateStr);
            println "reportDate = ${dateStr}"
            customerLogGeneratorJob.execute(CUSTOMER_LOG_QUERY, date);
            println "\n--- END (SUCCESS): AMLA Customer, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success:true,name:'AMLA Customer'])).build();
        }catch(Exception e){
            e.printStackTrace();
            System.err.println("customer: "+e.getCause()?.getMessage())
            println "\n--- END (FAILED): AMLA Customer, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
        }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/balance")
    public Response recordEndOfDayBalance(@Context UriInfo allUri) {

		println "\n--- START: Balance, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        println 'recordEndOfDayBalance'
        Gson gson = new Gson();
        Map returnMap = new HashMap();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();

		try {

			String currentDate = parameters?.getFirst(REPORT_DATE)?.toString()

            if (currentDate != null) {

                println "currentDate = ${currentDate}"
				dailyBalanceRecorderJob.execute(currentDate);

            } else {

                println "getAppServerDateString() = ${getAppServerDateString()}"
				dailyBalanceRecorderJob.execute(getAppServerDateString());
			}

            println "\n--- END (SUCCESS): Balance, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success:true,name:'Balance'])).build();

		} catch(Exception e) {

			System.err.println("Balance: " + e.printStackTrace())
			System.err.println("Balance: " + e.getCause()?.getMessage())
			println "\n--- END (FAILED): Balance, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/cifNormalization")
	public Response updateCifNumber(@Context UriInfo allUri){
		println "\n--- START: CIF Normalization, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();
		try{
			if(!cifNormalization.execute()){
				println "\n--- END(FAILED): CIF Normalization, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
				return Response.status(200).entity(gson.toJson([success : false])).build();				
			}else{
				println "\n--- END (SUCCESS): CIF Normalization, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
				return Response.status(200).entity(gson.toJson([success:true,name:'CIF Normalization'])).build();			
			}
	   }catch(Exception e){
			System.err.println("CIF Normalization: "+e);
			println "\n--- END (FAILED): CIF Normalization, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
	   }
	}
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/cifPurging")
	public Response cifPurging(@Context UriInfo allUri){
		
		Gson gson = new Gson();
		try{
			cifPurgingGeneratorJob.execute();
			return Response.status(200).entity(gson.toJson([success:true,name:'CIF Purging'])).build();
	   }catch(Exception e){
			System.err.println("CIF PURGING: "+e);
			println "\n--- END (FAILED): CIF PURGING, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
	   }
	}
	
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/expiredAmla")
	public Response expiredAmla(@Context UriInfo allUri){
		try{
			Gson gson = new Gson();
			SimpleDateFormat sdf = new SimpleDateFormat("MM-dd-yyyy");
			MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
			System.out.println("==================: "+parameters);
			String dateFrom = parameters.getFirst("dateFrom").toString();
			String dateTo = parameters.getFirst("dateTo").toString();
			System.out.println(dateFrom+" "+dateTo);
			
			Date date1 = new Date();
			Date date2 = new Date();
			
			if(parameters.getFirst("date")!=null){
				println("DAILY BATCH RUN");
				date1 = sdf.parse(parameters.getFirst("date").toString());
				date2 = sdf.parse(parameters.getFirst("date").toString());
			}else{
				println("ADHOC");
				date1 = sdf.parse(dateFrom);
				date2 = sdf.parse(dateTo);
			}
			
			amlaExpiredLcService.adhocExpiredAmla(date1,date2);
		
			return Response.status(200).entity(gson.toJson([success:true,name:'Amla Expire LC'])).build();
	   }catch(Exception e){
			System.err.println("CIF PURGING: "+e);
			println "\n--- END (FAILED): AMLA_EXPIRED, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
	   }

	}

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/dw")
    public Response generateDwParameterFiles(@Context UriInfo allUri){
		println "\n--- START DW Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        Map returnMap = new HashMap();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
		try{
	        String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
	        Assert.notNull(reportDate,"Report date must not be null!")
            println "reportDate:"+reportDate
	        dwParameterRecord.execute(DW_PARAMETER_FILE_SQL,DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate));
			println "\n--- END (SUCCESS): DW Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
	        return Response.status(200).entity(gson.toJson([success : true,name:'DW Parameter'])).build();
    	}catch(Exception e){
			e.printStackTrace();
			System.err.println("DW: "+e.getCause()?.getMessage())
			println "\n--- END (FAILED): DW Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }


    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/cbr")
    public Response generateDwCbrParameterFiles(@Context UriInfo allUri){
		println "\n--- START CBR Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        Map returnMap = new HashMap();
        MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
		try{
	        String reportDate = parameters?.getFirst(REPORT_DATE)?.toString();
	        Assert.notNull(reportDate,"Report date must not be null!")
            println "reportDate:"+reportDate
            cbrParameterFileGenerator.execute(CBR_PARAMETER_FILE_SQL,DATE_FORMATTER_BATCH_CONTROLLER.parse(reportDate));
			println "\n--- END (SUCCESS): CBR Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
	        return Response.status(200).entity(gson.toJson([success : true,name:'CBR Parameter'])).build();
    	}catch(Exception e){
			e.printStackTrace();
			System.err.println("CBR Parameter: "+e.getCause()?.getMessage())
			println "\n--- END (FAILED): CBR Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/tagAsPending")
	public Response tagAsPending(@Context UriInfo allUri, String postRequestBody) {
        println "\n--- START: Tag As Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson()

		String result="";
		Map returnMap = new HashMap();

		try {
			Map formDetails = gson.fromJson(postRequestBody, Map.class);
			String errorMessage = ""

			try{
				pas5FilesLoaderService.tagAsPending()

				returnMap.put("success", true);
				returnMap.put("name", "Tag As Pending");

                println "\n--- END (SUCCESS): Tag As Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"

			}catch (CasaServiceException e){
//				errorMessage = e.getErrorCode() + " : "  + e.getCasaErrorMessage();
				println "ERROR: "+ e.getErrorCode() + " : "  + e.getCasaErrorMessage();
//                returnMap.put("status", "error");
//                returnMap.put("error", errorMessage);
                println "\n--- END (FAILED): Tag As Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
				returnMap.put("success", false);
			}
		} catch(Exception e) {

			Map errorDetails = new HashMap();

			e.printStackTrace();

//            errorDetails.put("code", e.getMessage());
//            errorDetails.put("description", e.toString());
//
//            returnMap.put("status", "error");
//            returnMap.put("error", errorDetails);

            println "\n--- END (FAILED): Tag As Pending, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"

			returnMap.put("success", false);
		}

		// format return data as json
		result = gson.toJson(returnMap);

		return Response.status(200).entity(result).build();
	}

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/revalueEarmark")
    public Response revalueEarmark(@Context UriInfo allUri, String postRequestBody) {
        println "\n--- START: Re Value Earmark, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson()

        String result="";
        Map returnMap = new HashMap();

        try {
            Map formDetails = gson.fromJson(postRequestBody, Map.class);
            String errorMessage = ""

            try{
                batchFacilityRevaluationJob.execute();

                returnMap.put("success", true);
                returnMap.put("name", "Process Revalue");

                println "\n--- END (SUCCESS): Re Value Earmark, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"

            }catch (Exception e){
//				errorMessage = e.getErrorCode() + " : "  + e.getCasaErrorMessage();
                println "ERROR: "+ e.printStackTrace()
//                returnMap.put("status", "error");
//                returnMap.put("error", errorMessage);
                println "\n--- END (FAILED): Re Value Earmark, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
                returnMap.put("success", false);
            }
        } catch(Exception e) {

            Map errorDetails = new HashMap();

            e.printStackTrace();

//            errorDetails.put("code", e.getMessage());
//            errorDetails.put("description", e.toString());
//
//            returnMap.put("status", "error");
//            returnMap.put("error", errorDetails);

            println "\n--- END (FAILED): Re Value Earmark, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"

            returnMap.put("success", false);
        }

        // format return data as json
        result = gson.toJson(returnMap);

        return Response.status(200).entity(result).build();
    }
	
	@GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/pusoPogi")
    public Response pusoPogi(@Context UriInfo allUri, String postRequestBody) {
         println "\n etooo reqq bodyyyyyyyyy" + postRequestBody
		 println "\n etooo all uriiiiiiiiii" + allUri

		MultivaluedMap<String, String> parameters = allUri.getQueryParameters();
        String onlineReportDate = parameters?.getFirst(REPORT_DATE)?.toString();

		println "\n parammmmmmmsssss" + onlineReportDate

     	println "\n parammmmm 1111" 
        Gson gson = new Gson()
        // Map returnMap = new HashMap();
		// Map formDetails = gson.fromJson(postRequestBody, Map.class);

        String result="";
		String[] arrayResult;
		//String[] documentNumbers = tradeServiceRepository.getDocumentNumbersOfUnapprovedEts(DATE_FORMATTER.parse(onlineReportDate))


			println "pusssssssssssssss1111111111" + documentNumbers
			

		try{
	       // glParameterFileJob.execute(PUSO_CFMAST_SQL,DATE_FORMATTER_BATCH_CONTROLLER.parse(onlineReportDate));
			println "\n--- END (SUCCESS): Puso Pogiiii:" + DateUtil.convertToTimeString(new Date()) + "---"

			println "\n ---- arayyyyyyyyyyyy" + arrayResult
	        return Response.status(200).entity(gson.toJson([success : true,name:'Puso Pogi'])).build();
		}catch(Exception e){
			System.err.println("Parameter: "+ e.getCause()?.getMessage())
			println "\n--- END (FAILED): GL Parameter, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
        
        // format return data as json
       // result = gson.toJson(returnMap);
	   	// result = gson.toJson(returnMap)
   		// println "\n--- Cryssyyyyy poggiiiiiii ditooo naa enddddd"  + "---"
    //    return Response.status(200).entity(result).build();
    }
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/processRefBanks")
	public Response processRefBanks(@Context UriInfo allUri, String postRequestBody) {
		println "\n--- START: Process Ref Banks, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();

		String responseText="";
		Map returnMap = new HashMap();
		boolean responseStatus=true
		
		try {
			Map<String,Object> placeholder=new HashMap<String,Object>()
			List<String> columnList=new ArrayList<String>()
			int successCtr=0;
			int failCtr=0;
//			println "+++++++++rawr++++++++++++++++++++++"
//			println appProperties.object.getProperty("tfs.rmi.port")
//			appProperties.getObject()
//			println "+++++++++rawr++++++++++++++++++++++"
//			def fileMatcher = ~/(?i).*\.txt/
			FileInputStream fis = null
			boolean fileExist = false

			File refBankFile = new File(appProperties.object.getProperty('batch.bic.directory') + appProperties.object.getProperty('batch.bic.filename.all'))
			
			if(refBankFile == null){
				refBankFile = new File(appProperties.object.getProperty('batch.bic.directory') + appProperties.object.getProperty('batch.bic.filename.delta'))
			}
			
			if(refBankFile == null){
				throw new RuntimeException("FI.txt or FIDELTA.txt NOT FOUND")
			}
			
//			if(refBankFile.list() != null && refBankFile.list().length < 1){
//				throw new Exception("No File Found.")
//			}
			println refBankFile

			
			File backupFileDirectory= new File(appProperties.object.getProperty('batch.bic.backup.directory'))
			File bicBackupFile = null
			
			if(!backupFileDirectory.exists()){
				backupFileDirectory.mkdir()
			}
			
//			refBankFile.eachFileMatch(FileType.FILES,fileMatcher){f ->
				try{
					fis = new FileInputStream(refBankFile)
					bicBackupFile = new File(appProperties.object.getProperty('batch.bic.backup.directory') + refBankFile.getName())
					Scanner sc=new Scanner(fis);
					if(sc.hasNext()){
						String[] columnArray=sc.nextLine().split("\t")
							for(String s:columnArray){
								columnList.add(mapParametersToRefBankObject(s))
							}
					}
					
					while(sc.hasNext()){
						String[] oneLine=sc.nextLine().split("\t")
								
						placeholder=new HashMap<String,Object>()
						for(int x=0;x<columnList.size();x++){
							try{
								placeholder.put(columnList.get(x), oneLine[x])
							}catch(ArrayIndexOutOfBoundsException ex){
								continue;
							}
						}
						if(!refBankService.processRefBankDetails(placeholder)){
							failCtr++;
							responseStatus=false
						}else{
							successCtr++;
						}
					}
					
					//delete file after use
					fis.close()
					sc.close()
					if(refBankFile.exists()){
						FileUtil.copyFile(refBankFile, bicBackupFile)
						refBankFile.delete()						
					}
				}catch(Exception e){
					throw new Exception("EXCEPTION IN EACH FILE MATCH\n", e)
				}finally{
					IOUtils.closeQuietly(fis)
				}
//			}
			
			println "\n====FINISHED UPLOAD REF BANK=================="
			println "NO ERRORS ENCOUNTERED: "+responseStatus
			println "TOTAL ROWS: "+ (failCtr+successCtr)
			println "ROWS PROCESSED SUCCESS: "+successCtr
			println "ROWS PROCESSED FAIL: "+failCtr
			println "=============================================="
			
//			Map formDetails = gson.fromJson(postRequestBody, Map.class);
//			List<Map<String,Object>> bankList= (List<Map<String,Object>>) formDetails.get("responseTextList")
			
//			refBankService.processRefBankDetails(bankList);

			if(!responseStatus){
				returnMap.put("success", false);
				returnMap.put("failRows",failCtr);
				returnMap.put("totalRows",(failCtr+successCtr));
				returnMap.put("name", "Process Ref Banks");
				responseText = gson.toJson(returnMap);
				println "\n--- END (FAILED): Process Ref Banks, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
				return Response.status(404).entity(responseText).build();
			}else{
				returnMap.put("success", true);
				returnMap.put("successRows",successCtr);
				returnMap.put("totalRows",(failCtr+successCtr));
				returnMap.put("name", "Process Ref Banks");
				responseText = gson.toJson(returnMap);
				println "\n--- END (SUCESS): Process Ref Banks, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
				return Response.status(200).entity(responseText).build();
			}
		}catch(Exception e){
			e.printStackTrace();
			returnMap.put("success", false);
			returnMap.put("errorCode", e.getMessage());
			returnMap.put("description", e.toString());
			returnMap.put("name", "Process Ref Banks");
			responseText = gson.toJson(returnMap);
			println "\n--- END (FAILED): Process Ref Banks, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(500).entity(responseText).build();
		}
	}
	
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("/processRmaDocument")
	public Response processRmaDocument(@Context UriInfo allUri, String postRequestBody) {
		println "\n--- START: Process RMA Document, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
		Gson gson = new Gson();

		String responseText="";
		Map returnMap = new HashMap();

		try {

			int successCtr=0;
			int failCtr=0;
			int emptyCtr=0;
			int banksToSaveCtr=0;
			int banksProcessed=0;
			int processResult=0;
			
			def fileMatcher = ~/(?i).*\.xml/
			FileInputStream fis = null
			
			File rmaBankFile = new File(appProperties.object.getProperty('batch.rma.directory'))
			
			if(rmaBankFile.list() != null && rmaBankFile.list().length < 1){
				throw new Exception("No File Found.")
			}
			
			File backupFileDirectory= new File(appProperties.object.getProperty('batch.rma.backup.directory'))
			File rmaBankBackupFile = null
			
			if(!backupFileDirectory.exists()){
				backupFileDirectory.mkdir()
			}
			
			
			rmaBankFile.eachFileMatch(FileType.FILES,fileMatcher){f ->
				try{
					fis = new FileInputStream(f)
					rmaBankBackupFile = new File(appProperties.object.getProperty('batch.rma.backup.directory') + f.getName())
					SAXParserFactory saxFactory = SAXParserFactory.newInstance();
					SAXParser parser=saxFactory.newSAXParser();
					DefaultHandler handler = new RmaBankHandler();
					
					parser.parse(fis, handler);
					
					for(Map<String,Object> bankToSave:handler.getBanksToSave()){
						processResult=refBankService.processRmaDocument(bankToSave);
						switch(processResult){
						case 0:
							emptyCtr++;
							break;
						case -1:
							failCtr++;
							break;
						default:
							successCtr++;
							banksProcessed+=processResult;
							break;
						}
						banksToSaveCtr++;
					}
					//update ALL NULL REF BANKS
					refBankService.updateAllNullRmaRefBanks();
					//delete after use
					fis.close()
					if(f.exists()){
						FileUtil.copyFile(f, rmaBankBackupFile)
						f.delete()
					}
				}catch(Exception e){
					throw new Exception("Exception in Processing Each File in RMA",e)
				}finally{
					IOUtils.closeQuietly(fis)
				}
			}
			
			println "\n====FINISHED UPLOAD RMA DOCUMENT=================="
			println "TOTAL BANKS IDS TO SAVE: "+ banksToSaveCtr
			println "BANKS UPDATED SUCCESS: "+banksProcessed
			println "BANKS SAVE SUCCESS: "+successCtr
			println "BANKS SAVE FAIL: "+failCtr
			println "BANKS NOT FOUND IN DB: "+emptyCtr
			println "=============================================="
			
//			Map formDetails = gson.fromJson(postRequestBody, Map.class);
//			List<Map<String,Object>> bankList= (List<Map<String,Object>>) formDetails.get("responseTextList")
			
//			refBankService.processRefBankDetails(bankList);

				returnMap.put("success",true);
				returnMap.put("successBanks",successCtr);
				returnMap.put("failBanks",failCtr);
				returnMap.put("emptyBanks",emptyCtr);
				returnMap.put("processedBanks",banksProcessed);
				returnMap.put("totalBanks",banksToSaveCtr);
				returnMap.put("name", "Process Rma Document");
				responseText = gson.toJson(returnMap);
				println "\n--- END (SUCCESS): Process RMA Document, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
				return Response.status(200).entity(responseText).build();
				
		} catch(SAXException e) {
			e.printStackTrace();
			returnMap.put("success", false);
			returnMap.put("errorCode", e.getMessage());
			returnMap.put("description", "SAX EXCEPTION: "+e.toString());
			returnMap.put("name", "Process Rma Document");
			responseText = gson.toJson(returnMap);
			println "\n--- END (FAILED): Process RMA Document, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(500).entity(responseText).build();
		} catch(Exception e){
			e.printStackTrace();
			returnMap.put("success", false);
			returnMap.put("errorCode", e.getMessage());
			returnMap.put("description", e.toString());
			returnMap.put("name", "Process Rma Document");
			responseText = gson.toJson(returnMap);
			println "\n--- END (FAILED): Process RMA Document, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
			return Response.status(500).entity(responseText).build();
		}
	}
	
	private String mapParametersToRefBankObject(String paramName){
		switch(paramName){
//			--List of  RefBank properties not mapped---
//			private String rmaFlag;
//			private String depositoryFlag;
//			private String glBankCode;
//			private String rbuAccount;
//			private String fcduAccount;
//			private Currency reimbursingCurrency;
//			private Date updateDate;
//			private String updatedBy;
//			private String glCodeRbu;
//			private String glCodeFcdu;
//			private Long cbCreditorCode;
//			private String deleteFlag;
			case "BIC CODE":
				return "bic"
				break;
			case "BRANCH CODE":
				return "branchCode"
				break;
			case "INSTITUTION NAME":
				return "institutionName"
				break;
			case "BRANCH INFORMATION":
				return "branchInfo"
				break;
			case "CITY HEADING":
				return "city"
				break;
			case "PHYSICAL ADDRESS 1":
				return "address1"
				break;
			case "PHYSICAL ADDRESS 2":
				return "address2"
				break;
			case "PHYSICAL ADDRESS 3":
				return "address3"
				break;
			case "PHYSICAL ADDRESS 4":
				return "address4"
				break;
			case "LOCATION":
				return "location"
				break;
			default:
				return paramName
		}
	}



	
    private java.sql.Date getDate(String dateString){
        Date runDate = DATE_FORMATTER_DESC.parse(dateString)
        return new java.sql.Date(runDate.getTime());
    }

    private java.sql.Date getDate2(String dateString){
        Date runDate = DATE_FORMATTER.parse(dateString)
        return new java.sql.Date(runDate.getTime());
    }

    private java.sql.Date getAppServerDate() {
        Date runDate = new Date();
        return new java.sql.Date(runDate.getTime());
    }

    private java.sql.Date getAppServerDateString() {
        Date runDate = new Date();
        String dateString = DATE_FORMATTER.format(runDate);
        return dateString;
    }

    // test for cif normalization log
//    @POST
//    @Produces(MediaType.APPLICATION_JSON)
//    @Path("/logCifNormalization")
//    public Response logCifNormalization(@Context UriInfo allUri, String postRequestBody) {
//        Gson gson = new Gson()
//
//        String result="";
//        Map returnMap = new HashMap();
//
//        try {
//            def cifNormalizationMap = ["oldCifNumber":"CIFNUM-01",
//                                       "oldCifName":"O-CIFNAME",
//                                       "newCifNumber":"CIFNUM-02",
//                                       "newCifName":"N-CIFNAME",
//                                       "oldMainCifNumber":"MCIFNUM-01",
//                                       "oldMainCifName":"O-MAINCIFNAME",
//                                       "newMainCifNumber":"MCIFNUM-02",
//                                       "newMainCifName":"N-MAINCIFNAME"]
//
//            cifNormalizationLogService.saveCifNormalizationLog(cifNormalizationMap, new Date(), BigDecimal.ONE, BigDecimal.TEN);
//
//            cifNormalizationLogService.createLogFile();
//
//        } catch(Exception e) {
//
//            Map errorDetails = new HashMap();
//
//            e.printStackTrace();
//
//            errorDetails.put("code", e.getMessage());
//            errorDetails.put("description", e.toString());
//
//            returnMap.put("status", "error");
//            returnMap.put("error", e.getMessage());
//        }
//
//        // format return data as json
//        result = gson.toJson(returnMap);
//
//        return Response.status(200).entity(result).build();
//    }


    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/cloneLnappf")
    public Response cloneLnappf(@Context UriInfo allUri) {
        println "\n--- START: Cloning LNAPPF, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();

        String result="";
        Map returnMap = new HashMap();
        Map jsonParams = new HashMap<String, String>();

        // get all query parameters
        MultivaluedMap<String, String> mpAllQueParams = allUri.getQueryParameters();

        try {
            facilityReferenceNormalization.executeFacilityReferenceNormalization();

			println "\n--- END (SUCCESS) : Cloning LNAPPF, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            returnMap.put("success", true);
			returnMap.put("name", "Clone LNAPPF");
        } catch(Exception e) {
            e.printStackTrace();
			println "\n--- END (FAILED) : Cloning LNAPPF, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            returnMap.put("success", false);
        }

        // format return data as json
        result = gson.toJson(returnMap);

        return Response.status(200).entity(result).build();
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/getAllLnappf")
    public Response getAllLnappf(@Context UriInfo allUri) {
        Gson gson = new Gson();

        String result="";
        Map returnMap = new HashMap();
        Map jsonParams = new HashMap<String, String>();

        // get all query parameters
        MultivaluedMap<String, String> mpAllQueParams = allUri.getQueryParameters();

        try {
            try{
                def lnappfEntries = facilityReferenceNormalization.getAllLnappfEntries();

                returnMap.put("response", lnappfEntries)
                returnMap.put("success", true);
            }catch (Exception e){
                println "ERROR: "+ e.printStackTrace();
                returnMap.put("success", false);
            }
        } catch(Exception e) {
            e.printStackTrace();

            returnMap.put("success", false);
        }

        // format return data as json
        result = gson.toJson(returnMap);

        return Response.status(200).entity(result).build();
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/purgeSecEmployeeAudit")
    public Response purgeSecEmployeeAudit(@Context UriInfo allUri) {
        println "\n--- START: Purge SEC_EMPLOYEE_AUDIT, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        try {
            purgeSecEmloyeeAuditJob.execute();
            println "\n--- END (SUCCESS): Purge SEC_EMPLOYEE_AUDIT, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : true,name:'Purge SEC_EMPLOYEE_AUDIT'])).build();
        } catch(Exception e) {
            e.printStackTrace();
            System.err.println("Purge SEC_EMPLOYEE_AUDIT = " + e.getCause()?.getMessage())
            println "\n--- END (FAILED): Purge SEC_EMPLOYEE_AUDIT, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : false])).build();
        }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/updateAllocationUnitCode")
    public Response updateAllocationUnitCode(@Context UriInfo allUri) {

		String response = "true";
		
        println "\n--- START: Update Allocation Unit Code, TIME: " + DateUtil.convertToTimeString(new Date()) + " ---\n"

        Gson gson = new Gson();

        Map jsonParams = new HashMap<String, String>();

        // get all query parameters
        MultivaluedMap<String, String> mpAllQueParams = allUri.getQueryParameters();

        for(String key : mpAllQueParams.keySet()) {

            // if there are multiple instances of the same param, we only use the first one
            jsonParams.put(key, mpAllQueParams.getFirst(key).toString());
        }

        try {
            // This param is for TESTING only
            // Acts as a filter if we do not want to update all records at the same time
            String cifNumber = jsonParams.get("cifNumber")

            response = allocationUnitCodeService.executeUpdate(cifNumber);
            
        } catch(Exception e) {
            e.printStackTrace();
			response = "false";
            System.err.println("updateAllocationUnitCode: " + e.getCause()?.getMessage());
        }
		
		if(response.equalsIgnoreCase("true")) {
			println "\n--- END (SUCCESS) : Update Allocation Unit Code, TIME: " + DateUtil.convertToTimeString(new Date()) + " ---"
			return Response.status(200).entity(gson.toJson([success : true, name : 'Update Allocation Unit Code'])).build();
		} else {
			println "\n--- END (FAILED): Update Allocation Unit Code, TIME: " + DateUtil.convertToTimeString(new Date()) + " ---"
			return Response.status(200).entity(gson.toJson([success : false])).build();
		}
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/updateTransactionRouting")
    public Response updateTransactionRouting(@Context UriInfo allUri) {
        println "\n--- START: Update Transaction Routing, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
        Gson gson = new Gson();
        try {
            uploadRoutingJob.execute();
            println "\n--- END (SUCCESS): Update Transaction Routing, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : true,name:'Update Transaction Routing'])).build();
        } catch(Exception e) {
            e.printStackTrace();
            System.err.println("Update Transaction Routing = " + e.getCause()?.getMessage())
            println "\n--- END (FAILED): Update Transaction Routing, TIME:" + DateUtil.convertToTimeString(new Date()) + "---"
            return Response.status(200).entity(gson.toJson([success : false])).build();
        }
    }
}
